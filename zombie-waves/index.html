<!--
MIT License

Copyright (c) 2026 Bloxcraft Studios

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
-->
<!DOCTYPE HTML>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Player V.S Zombies - By: Bloxcraft Studios</title>
<style>
  :root{
    --bg:#071018; --panel:#081323; --accent:#ff6b6b; --accent2:#4cc9f0; --muted:#9aa8b2;
    --hud-bg: rgba(0,0,0,0.25);
  }
  html,body{height:100%;margin:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial;color:#e6eef8;background:linear-gradient(180deg,#051218,#071a25);}
  .center{display:flex;align-items:center;justify-content:center;height:100%}
  canvas{display:block;border-radius:12px;background:linear-gradient(180deg,#08202a,#04121a);box-shadow:0 10px 30px rgba(2,6,23,0.6)}
  /* overlays & UI */
  .overlay { position:fixed; inset:0; display:flex; align-items:center; justify-content:center; z-index:60; backdrop-filter: blur(6px); }
  .card{ background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border:1px solid rgba(255,255,255,0.04); padding:18px; border-radius:12px; min-width:280px; max-width:620px; text-align:center; color:inherit; }
  h1{margin:0 0 8px 0;font-size:20px}
  p.small{margin:0 0 12px;color:var(--muted)}
  .controls{display:flex;gap:12px;justify-content:center;flex-wrap:wrap}
  .btn{background:var(--accent);color:#071018;padding:10px 14px;border-radius:10px;border:none;font-weight:700;cursor:pointer}
  .btn.alt{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted)}
  .hud{position:fixed;left:12px;top:12px;z-index:50;background:var(--hud-bg);padding:8px 12px;border-radius:10px;border:1px solid rgba(255,255,255,0.03);font-size:14px}
  .hud .row{display:flex;gap:14px;align-items:center}
  .right-hud{position:fixed;right:12px;top:12px;z-index:50;background:var(--hud-bg);padding:8px 12px;border-radius:10px;border:1px solid rgba(255,255,255,0.03);font-size:14px}
  .mobile-controls{position:fixed;left:12px;right:12px;bottom:12px;z-index:70;display:flex;justify-content:space-between;align-items:flex-end;gap:12px}
  .joystick{width:120px;height:120px;border-radius:999px;background:rgba(255,255,255,0.02);display:flex;align-items:center;justify-content:center;touch-action:none}
  .stick{width:48px;height:48px;border-radius:999px;background:linear-gradient(180deg,#83c5be,#2b8e84);box-shadow:0 6px 14px rgba(0,0,0,0.6);transform:translate(0,0)}
  .aim-stick{width:56px;height:56px;border-radius:999px;background:linear-gradient(180deg,#ffd166,#ffb703);box-shadow:0 6px 14px rgba(0,0,0,0.6)}
  .shoot-btn{width:80px;height:80px;border-radius:999px;background:linear-gradient(180deg,var(--accent),#ff7b7b);display:flex;align-items:center;justify-content:center;font-weight:900;color:#071018;box-shadow:0 10px 20px rgba(0,0,0,0.6);touch-action:none}
  .hint{position:fixed;left:50%;transform:translateX(-50%);bottom:16px;color:var(--muted);font-size:13px;z-index:40}
  .gameover{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:80;background:linear-gradient(180deg,rgba(0,0,0,0.45),rgba(0,0,0,0.6));}
  .level-info{position:fixed;left:50%;transform:translateX(-50%);top:12px;background:var(--hud-bg);padding:8px 12px;border-radius:10px;border:1px solid rgba(255,255,255,0.03);font-weight:700}
  .small-muted{font-size:12px;color:var(--muted)}
  kbd{background:rgba(255,255,255,0.04);padding:2px 6px;border-radius:6px;font-weight:700}
  @media (max-width:720px){
    canvas{width:100%;height:100%}
    .hud{left:8px;top:8px}
    .right-hud{right:8px;top:8px}
    .mobile-controls{left:8px;right:8px;bottom:8px}
  }
</style>
</head>
<body>
  <!-- Start overlay: pick device or auto-detect -->
  <div id="startOverlay" class="overlay" role="dialog" aria-modal="true">
    <div class="card">
      <h1>Player V.S Zombies - By: Bloxcraft Studios</h1>
      <p class="small">Select how you want to play. Buttons respond to both <strong>click</strong> and <strong>tap</strong>.</p>
      <div style="display:flex;gap:12px;justify-content:center;flex-wrap:wrap">
        <button id="autoBtn" class="btn">Auto-detect device</button>
        <button id="desktopBtn" class="btn alt">Desktop — Keyboard + Mouse</button>
        <button id="mobileBtn" class="btn alt">Mobile — Dual-stick</button>
      </div>
      <p class="small" style="margin-top:12px">Desktop: <kbd>W A S D</kbd> or arrows to move, mouse to aim, click to shoot. Mobile: left stick to move, right stick to aim (auto-fire while aiming).</p>
      <div style="margin-top:8px;font-size:13px" class="small-muted">Best Score & Level saved locally.</div>
    </div>
  </div>

  <!-- HUD -->
  <div id="hud" class="hud" style="display:none">
    <div class="row"><div>Score: <span id="score">0</span></div><div>Health: <span id="health">100</span></div></div>
    <div style="margin-top:6px" class="small-muted">Zombies left: <span id="zleft">0</span></div>
  </div>
  <div id="rightHud" class="right-hud" style="display:none">
    <div>Level: <span id="level">1</span> / 100</div>
    <div class="small-muted">Best Level: <span id="bestLevel">0</span></div>
  </div>
  <div id="levelInfo" class="level-info" style="display:none">Wave <span id="waveNum">1</span> — <span id="waveType">Standard</span></div>

  <!-- Canvas -->
  <div class="center">
    <canvas id="gameCanvas" width="1080" height="720" style="max-width:96vw;max-height:88vh"></canvas>
  </div>

  <!-- Mobile controls -->
  <div id="mobileControls" class="mobile-controls" style="display:none">
    <div class="joystick" id="moveBase"><div class="stick" id="moveStick"></div></div>
    <div style="display:flex;flex-direction:column;gap:10px;align-items:center">
      <div class="joystick" id="aimBase" style="width:110px;height:110px"><div class="aim-stick" id="aimStick"></div></div>
      <div class="small-muted">Aim to auto-fire</div>
    </div>
  </div>

  <div id="hint" class="hint">Press <kbd>Space</kbd> to pause</div>

  <!-- Game Over / Level Complete -->
  <div id="gameover" class="gameover" style="display:none">
    <div class="card">
      <h2 id="goTitle">You died</h2>
      <p class="small" id="goText">Score: 0 • Reached level 1</p>
      <div style="display:flex;gap:8px;justify-content:center;margin-top:12px">
        <button id="restartBtn" class="btn">Restart</button>
        <button id="changeBtn" class="btn alt">Change Device</button>
      </div>
    </div>
  </div>

<script>
/* Very Great Zombie Game — 100 Levels (single file)
   Features:
   - 100 levels
   - Multiple zombie types (Slow, Runner, Tank, Exploder, Boss)
   - Desktop: WASD/arrow keys + mouse aim + click to shoot
   - Mobile: Dual-stick (left move, right aim) with auto-fire while aiming
   - Level progression: kill all zombies to advance
   - Persistent best score & level in localStorage
*/

/* ---- Canvas & Resize ---- */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d', { alpha: false });
let W = canvas.width, H = canvas.height;

function resizeCanvas() {
  const ratio = W / H;
  const vw = Math.min(window.innerWidth - 24, 1400);
  const vh = Math.min(window.innerHeight - 48, 1000);
  let newW = vw, newH = Math.round(vw / ratio);
  if (newH > vh) { newH = vh; newW = Math.round(vh * ratio); }
  canvas.style.width = newW + 'px';
  canvas.style.height = newH + 'px';
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();
function fixHiDPI(){
  const dpr = window.devicePixelRatio || 1;
  canvas.width = Math.round(W * dpr);
  canvas.height = Math.round(H * dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
  resizeCanvas();
}
fixHiDPI();

/* ---- Game State ---- */
const MAX_LEVEL = 100;
let state = {
  running: false,
  paused: false,
  mode: 'desktop', // desktop | mobile
  level: 1,
  score: 0,
  player: null,
  zombies: [],
  bullets: [],
  lastSpawn: 0,
  spawnInterval: 1000,
  pointer: { x: W/2, y: H/2 },
  lastTs: 0,
  bestScore: 0,
  bestLevel: 0
};

/* load bests */
try {
  const saved = JSON.parse(localStorage.getItem('vz_best')||'{}');
  state.bestScore = saved.score || 0;
  state.bestLevel = saved.level || 0;
} catch(e) { state.bestScore = 0; state.bestLevel = 0; }

/* ---- Utility ---- */
function rand(min,max){ return Math.random()*(max-min)+min; }
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }
function dist(a,b,c,d){ return Math.hypot(a-c,b-d); }

/* ---- Player ---- */
function createPlayer(){
  return {
    x: W/2, y: H/2, r: 16,
    speed: 240, vx:0, vy:0,
    health: 100,
    fireRate: 160, lastShot:0,
    dmg: 1
  };
}

/* ---- Zombie types ----
   type: 'walker' | 'runner' | 'tank' | 'exploder' | 'boss'
*/
function zombieTemplate(type, level){
  // base stats scale with level
  const difficulty = Math.max(1, Math.min(10, Math.floor(level/10)+1));
  if(type === 'walker'){
    return { r: rand(12,18), speed: rand(30,50) + level*0.4, hp: 1 + Math.floor(level/10), color:'#6fb98f', score:10 };
  }
  if(type === 'runner'){
    return { r: rand(10,14), speed: rand(80,140) + level*0.8, hp: 1, color:'#f6bd60', score:12 };
  }
  if(type === 'tank'){
    return { r: rand(20,30), speed: rand(18,34) + level*0.2, hp: 3 + Math.floor(level/5), color:'#8e6c88', score:25 };
  }
  if(type === 'exploder'){
    return { r: rand(12,18), speed: rand(60,100) + level*0.6, hp:1, color:'#ff6b6b', score:18, explode:true, explodeRadius:48 + level*0.6 };
  }
  if(type === 'boss'){
    return { r: 46 + Math.min(40,level*0.6), speed: 40 + level*0.6, hp: 20 + level*4, color:'#ffd166', score: 200, boss:true };
  }
  // default walker
  return { r: 14, speed: 40 + level*0.4, hp:1, color:'#6fb98f', score:10 };
}

/* spawn a zombie around edges */
function spawnZombie(level, type=null){
  const side = Math.floor(rand(0,4));
  let x,y;
  const margin = 60;
  if(side===0){ x = -margin; y = rand(0,H); }
  else if(side===1){ x = W+margin; y = rand(0,H); }
  else if(side===2){ x = rand(0,W); y = -margin; }
  else { x = rand(0,W); y = H+margin; }

  if(!type){
    // pick types based on level progression
    const p = Math.random();
    if(level >= 90 && p < 0.07) type = 'boss';
    else if(level >= 50 && p < 0.12) type = 'tank';
    else if(level >= 30 && p < 0.14) type = 'exploder';
    else if(level >= 8 && p < 0.2) type = 'runner';
    else type = 'walker';
  }
  const t = zombieTemplate(type, level);
  const z = { x, y, type, r: t.r, speed: t.speed, hp: t.hp, color: t.color, score: t.score };
  if(t.explode) { z.explode = true; z.explodeRadius = t.explodeRadius; }
  if(t.boss) { z.boss = true; z.hp = t.hp; z.score = t.score; }
  state.zombies.push(z);
}

/* ---- Input Handling ---- */
const keys = {};
window.addEventListener('keydown', e => {
  keys[e.key.toLowerCase()] = true;
  if(e.code === 'Space') state.paused = !state.paused;
});
window.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });

/* Mouse aiming and shooting */
let mouseDown = false;
canvas.addEventListener('mousemove', e => {
  const rect = canvas.getBoundingClientRect();
  const scaleX = W / rect.width, scaleY = H / rect.height;
  state.pointer.x = (e.clientX - rect.left) * scaleX;
  state.pointer.y = (e.clientY - rect.top) * scaleY;
});
canvas.addEventListener('mousedown', e => { mouseDown = true; tryShoot(); });
canvas.addEventListener('mouseup', e => { mouseDown = false; });
canvas.addEventListener('touchstart', e => {
  e.preventDefault();
  const t = e.changedTouches[0];
  const rect = canvas.getBoundingClientRect();
  const scaleX = W / rect.width, scaleY = H / rect.height;
  state.pointer.x = (t.clientX - rect.left) * scaleX;
  state.pointer.y = (t.clientY - rect.top) * scaleY;
  if(state.mode === 'desktop'){ tryShoot(); } // let touch act as click on desktop mode
}, {passive:false});
canvas.addEventListener('touchmove', e => {
  const t = e.changedTouches[0];
  const rect = canvas.getBoundingClientRect();
  const scaleX = W / rect.width, scaleY = H / rect.height;
  state.pointer.x = (t.clientX - rect.left) * scaleX;
  state.pointer.y = (t.clientY - rect.top) * scaleY;
}, {passive:true});

/* ---- Shooting / Bullets ---- */
function tryShoot(){
  const now = performance.now();
  const p = state.player;
  if(!p) return;
  if(now - p.lastShot < p.fireRate) return;
  p.lastShot = now;
  const dirX = state.pointer.x - p.x, dirY = state.pointer.y - p.y;
  const mag = Math.hypot(dirX,dirY) || 1;
  const speed = 980;
  const b = {
    x: p.x + (dirX/mag)*(p.r+8),
    y: p.y + (dirY/mag)*(p.r+8),
    vx: (dirX/mag) * speed,
    vy: (dirY/mag) * speed,
    r: 4,
    life: 1200,
    dmg: p.dmg
  };
  state.bullets.push(b);
}

/* ---- Mobile Dual Stick ---- */
const moveBase = document.getElementById('moveBase'), moveStick = document.getElementById('moveStick');
const aimBase = document.getElementById('aimBase'), aimStick = document.getElementById('aimStick');

let moveJoy = { active:false, id:null, startX:0, startY:0, dx:0, dy:0, max:42 };
let aimJoy = { active:false, id:null, startX:0, startY:0, dx:0, dy:0, max:44 };

// helper to convert stick screen coords to velocities
function applyMoveJoy(){
  const p = state.player; if(!p) return;
  const dx = moveJoy.dx, dy = moveJoy.dy;
  const mag = Math.hypot(dx,dy);
  if(mag < 6){ p.vx = 0; p.vy = 0; return; }
  p.vx = (dx/mag) * p.speed;
  p.vy = (dy/mag) * p.speed;
}
function applyAimJoy(){
  const mag = Math.hypot(aimJoy.dx, aimJoy.dy);
  if(mag < 6) return;
  const rect = canvas.getBoundingClientRect();
  const scaleX = W / rect.width, scaleY = H / rect.height;
  // aim pointer relative to player
  const p = state.player;
  if(!p) return;
  state.pointer.x = p.x + (aimJoy.dx / aimJoy.max) * 200;
  state.pointer.y = p.y + (aimJoy.dy / aimJoy.max) * 200;
  // auto-shoot while aiming
  tryShoot();
}

/* touch listeners: move joystick */
moveBase.addEventListener('touchstart', e => {
  const t = e.changedTouches[0];
  moveJoy.active = true; moveJoy.id = t.identifier;
  const rect = moveBase.getBoundingClientRect();
  moveJoy.startX = rect.left + rect.width/2;
  moveJoy.startY = rect.top + rect.height/2;
}, {passive:true});
moveBase.addEventListener('touchmove', e => {
  for(let i=0;i<e.changedTouches.length;i++){
    const t = e.changedTouches[i];
    if(t.identifier !== moveJoy.id) continue;
    moveJoy.dx = clamp(t.clientX - moveJoy.startX, -moveJoy.max, moveJoy.max);
    moveJoy.dy = clamp(t.clientY - moveJoy.startY, -moveJoy.max, moveJoy.max);
    moveStick.style.transform = `translate(${moveJoy.dx}px, ${moveJoy.dy}px)`;
    applyMoveJoy();
  }
}, {passive:true});
moveBase.addEventListener('touchend', e => {
  for(let i=0;i<e.changedTouches.length;i++){
    const t = e.changedTouches[i];
    if(t.identifier !== moveJoy.id) continue;
    moveJoy.active = false; moveJoy.id = null; moveJoy.dx=0; moveJoy.dy=0;
    moveStick.style.transform = `translate(0px,0px)`; applyMoveJoy();
  }
}, {passive:true});

/* aim joystick */
aimBase.addEventListener('touchstart', e => {
  const t = e.changedTouches[0];
  aimJoy.active = true; aimJoy.id = t.identifier;
  const rect = aimBase.getBoundingClientRect();
  aimJoy.startX = rect.left + rect.width/2;
  aimJoy.startY = rect.top + rect.height/2;
}, {passive:true});
aimBase.addEventListener('touchmove', e => {
  for(let i=0;i<e.changedTouches.length;i++){
    const t = e.changedTouches[i];
    if(t.identifier !== aimJoy.id) continue;
    aimJoy.dx = clamp(t.clientX - aimJoy.startX, -aimJoy.max, aimJoy.max);
    aimJoy.dy = clamp(t.clientY - aimJoy.startY, -aimJoy.max, aimJoy.max);
    aimStick.style.transform = `translate(${aimJoy.dx}px, ${aimJoy.dy}px)`;
    applyAimJoy();
  }
}, {passive:true});
aimBase.addEventListener('touchend', e => {
  for(let i=0;i<e.changedTouches.length;i++){
    const t = e.changedTouches[i];
    if(t.identifier !== aimJoy.id) continue;
    aimJoy.active = false; aimJoy.id = null; aimJoy.dx=0; aimJoy.dy=0;
    aimStick.style.transform = `translate(0px,0px)`;
  }
}, {passive:true});

/* mouse drag support for sticks (desktop-friendly) */
let moveMouseDown=false, aimMouseDown=false;
moveBase.addEventListener('mousedown', e => {
  moveMouseDown=true;
  const rect = moveBase.getBoundingClientRect();
  moveJoy.startX = rect.left + rect.width/2; moveJoy.startY = rect.top + rect.height/2;
});
window.addEventListener('mousemove', e => {
  if(moveMouseDown){
    moveJoy.dx = clamp(e.clientX - moveJoy.startX, -moveJoy.max, moveJoy.max);
    moveJoy.dy = clamp(e.clientY - moveJoy.startY, -moveJoy.max, moveJoy.max);
    moveStick.style.transform = `translate(${moveJoy.dx}px, ${moveJoy.dy}px)`; applyMoveJoy();
  }
  if(aimMouseDown){
    aimJoy.dx = clamp(e.clientX - aimJoy.startX, -aimJoy.max, aimJoy.max);
    aimJoy.dy = clamp(e.clientY - aimJoy.startY, -aimJoy.max, aimJoy.max);
    aimStick.style.transform = `translate(${aimJoy.dx}px, ${aimJoy.dy}px)`; applyAimJoy();
  }
});
window.addEventListener('mouseup', e => {
  if(moveMouseDown){ moveMouseDown=false; moveJoy.dx=0; moveJoy.dy=0; moveStick.style.transform='translate(0px,0px)'; applyMoveJoy(); }
  if(aimMouseDown){ aimMouseDown=false; aimJoy.dx=0; aimJoy.dy=0; aimStick.style.transform='translate(0px,0px)'; }
});
aimBase.addEventListener('mousedown', e => {
  aimMouseDown=true;
  const rect = aimBase.getBoundingClientRect();
  aimJoy.startX = rect.left + rect.width/2; aimJoy.startY = rect.top + rect.height/2;
});

/* ---- Update & Render ---- */
function update(dt){
  if(state.paused || !state.running) return;
  const p = state.player;
  // spawn logic: per level spawn all at start, or gradually spawn?
  // We'll spawn waves at a faster pace and maintain a target total
  if(state.zombiesToSpawn > 0){
    state.lastSpawn += dt;
    if(state.lastSpawn >= state.spawnInterval){
      state.lastSpawn = 0;
      // spawn one or multiple based on level
      const to = Math.min(3, state.zombiesToSpawn);
      for(let i=0;i<to;i++){ spawnZombie(state.level); state.zombiesToSpawn--; }
    }
  }

  // player movement: keyboard for desktop
  if(state.mode === 'desktop'){
    let mx=0,my=0;
    if(keys['w']||keys['arrowup']) my -= 1;
    if(keys['s']||keys['arrowdown']) my += 1;
    if(keys['a']||keys['arrowleft']) mx -= 1;
    if(keys['d']||keys['arrowright']) mx += 1;
    const mag = Math.hypot(mx,my);
    if(mag>0){ p.vx = (mx/mag)*p.speed; p.vy = (my/mag)*p.speed; } else { p.vx=0; p.vy=0; }
    if(mouseDown) tryShoot();
  } else {
    // mobile: movement already applied by joystick to p.vx/p.vy
  }

  // apply velocity
  p.x += p.vx * dt/1000; p.y += p.vy * dt/1000;
  p.x = clamp(p.x, 8, W-8); p.y = clamp(p.y, 8, H-8);

  // bullets update & collision
  for(let i=state.bullets.length-1;i>=0;i--){
    const b = state.bullets[i];
    b.x += b.vx * dt/1000; b.y += b.vy * dt/1000;
    b.life -= dt;
    if(b.life <= 0 || b.x < -40 || b.x > W+40 || b.y < -40 || b.y > H+40){
      state.bullets.splice(i,1); continue;
    }
    // check collision with zombies
    for(let j=state.zombies.length-1;j>=0;j--){
      const z = state.zombies[j];
      if(dist(b.x,b.y,z.x,z.y) < b.r + z.r){
        z.hp -= b.dmg;
        state.bullets.splice(i,1);
        if(z.hp <= 0){
          // handle explosion or boss death
          if(z.explode){
            // damage nearby entities including player
            for(let k=state.zombies.length-1;k>=0;k--){
              const z2 = state.zombies[k];
              if(dist(z.x,z.y,z2.x,z2.y) < (z.explodeRadius + z2.r)){
                z2.hp -= 1;
                if(z2.hp <= 0){ state.score += z2.score; state.zombies.splice(k,1); }
              }
            }
            // player damage if close
            if(dist(z.x,z.y,p.x,p.y) < z.explodeRadius + p.r){
              p.health -= 8;
            }
          }
          // reward
          state.score += z.score || 10;
          state.zombies.splice(j,1);
        }
        break;
      }
    }
  }

  // zombies move & collide with player
  for(let i=state.zombies.length-1;i>=0;i--){
    const z = state.zombies[i];
    const dx = p.x - z.x, dy = p.y - z.y;
    const d = Math.hypot(dx,dy) || 1;
    z.x += (dx/d) * z.speed * dt/1000;
    z.y += (dy/d) * z.speed * dt/1000;
    // collision with player
    if(dist(z.x,z.y,p.x,p.y) < z.r + p.r){
      // damage depending on type
      let dmg = 8;
      if(z.type === 'runner') dmg = 6;
      if(z.type === 'tank') dmg = 14;
      if(z.boss) dmg = 18;
      p.health -= dmg;
      // remove zombie or reduce hp
      z.hp -= 1;
      if(z.hp <= 0){
        state.score += z.score || 10;
        state.zombies.splice(i,1);
      } else {
        // push zombie slightly back to avoid stacking
        z.x -= (dx/d) * 12;
        z.y -= (dy/d) * 12;
      }
      if(p.health <= 0) { onPlayerDeath(); return; }
    }
  }

  // update HUD & win condition
  document.getElementById('score').textContent = Math.floor(state.score);
  document.getElementById('health').textContent = Math.max(0, Math.floor(p.health));
  document.getElementById('zleft').textContent = state.zombies.length + state.zombiesToSpawn;
  // win condition: level cleared (no active zombies and none left to spawn)
  if(state.zombies.length === 0 && state.zombiesToSpawn === 0){
    // level complete
    advanceLevel();
  }
}

/* ---- Level system ---- */
function setupLevel(level){
  state.level = level;
  // compute how many zombies for this level
  // base count increases, with occasional boss
  let base = Math.round(6 + level * 1.6 + (level/3));
  if(level % 10 === 0) {
    base = Math.max(base, 8) + 1; // boss level adds a boss plus fewer adds
    // ensure we place a boss
  }
  state.zombies = [];
  state.bullets = [];
  state.zombiesToSpawn = base;
  state.spawnInterval = clamp(1000 - level*8, 180, 1400);
  state.lastSpawn = 0;
  state.player.x = W/2; state.player.y = H/2;
  state.player.health = Math.min(100, state.player.health + 10); // small heal
  // If it's a boss level, schedule a boss spawn earlier
  if(level % 10 === 0){
    // reduce normal spawn a bit, force a boss spawn after a short delay
    state.zombiesToSpawn = Math.max(0, base - 2);
    // spawn boss after 900ms
    setTimeout(()=> spawnZombie(level,'boss'), 900);
  }
  // update UI
  document.getElementById('level').textContent = level;
  document.getElementById('waveNum').textContent = level;
  document.getElementById('waveType').textContent = (level % 10 === 0) ? 'Boss Level' : 'Standard';
  updateBestDisplays();
}

/* advance to next level (up to MAX_LEVEL) */
function advanceLevel(){
  if(state.level >= MAX_LEVEL){
    // final victory
    showGameOver(true);
    return;
  }
  // small inter-level delay & bonus
  state.score += Math.max(0, Math.floor(30 + state.level * 4));
  setupLevel(state.level + 1);
}

/* ---- Player death & Game Over ---- */
function onPlayerDeath(){
  state.running = false;
  // update bests
  if(state.score > state.bestScore) state.bestScore = Math.floor(state.score);
  if(state.level > state.bestLevel) state.bestLevel = state.level;
  localStorage.setItem('vz_best', JSON.stringify({score:state.bestScore, level:state.bestLevel}));
  showGameOver(false);
}

/* ---- UI: overlays & start ---- */
const startOverlay = document.getElementById('startOverlay');
const mobileControls = document.getElementById('mobileControls');
const hud = document.getElementById('hud');
const rightHud = document.getElementById('rightHud');
const levelInfo = document.getElementById('levelInfo');

function startGameWithMode(mode){
  state.mode = mode;
  state.player = createPlayer();
  state.player.health = 100;
  state.score = 0;
  state.zombies = [];
  state.bullets = [];
  state.running = true;
  state.paused = false;
  setupLevel(1);
  startOverlay.style.display = 'none';
  hud.style.display = 'block';
  rightHud.style.display = 'block';
  levelInfo.style.display = 'block';
  mobileControls.style.display = (mode === 'mobile') ? 'flex' : 'none';
  // reset sticks visually
  moveStick.style.transform = 'translate(0px,0px)';
  aimStick.style.transform = 'translate(0px,0px)';
  state.lastTs = performance.now();
}

document.getElementById('desktopBtn').addEventListener('click', ()=> startGameWithMode('desktop'));
document.getElementById('mobileBtn').addEventListener('click', ()=> startGameWithMode('mobile'));
document.getElementById('autoBtn').addEventListener('click', ()=>{
  const isMobile = /Mobi|Android|iPhone|iPad|iPod|Opera Mini/i.test(navigator.userAgent);
  startGameWithMode(isMobile ? 'mobile' : 'desktop');
});
document.getElementById('restartBtn').addEventListener('click', ()=>{
  document.getElementById('gameover').style.display = 'none';
  startOverlay.style.display = 'none';
  startGameWithMode(state.mode || 'desktop');
});
document.getElementById('changeBtn').addEventListener('click', ()=>{
  location.reload();
});

function showGameOver(victory=false){
  const go = document.getElementById('gameover');
  go.style.display = 'flex';
  document.getElementById('goTitle').textContent = victory ? 'You conquered the horde!' : 'You died';
  document.getElementById('goText').textContent = `Score: ${Math.floor(state.score)} • Reached level ${state.level}`;
  // update best displays
  updateBestDisplays();
}

/* update best score displays in HUD */
function updateBestDisplays(){
  document.getElementById('bestLevel').textContent = state.bestLevel;
  // persist if new bests
  if(state.score > state.bestScore) state.bestScore = Math.floor(state.score);
  if(state.level > state.bestLevel) state.bestLevel = state.level;
  localStorage.setItem('vz_best', JSON.stringify({score:state.bestScore, level:state.bestLevel}));
}

/* ---- Main loop ---- */
function render(){
  // clear
  ctx.fillStyle = '#041219';
  ctx.fillRect(0,0,W,H);

  // subtle grid
  ctx.strokeStyle = 'rgba(255,255,255,0.02)';
  ctx.lineWidth = 1;
  for(let x=0;x<W;x+=64){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); }
  for(let y=0;y<H;y+=64){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }

  // draw bullets
  for(const b of state.bullets){
    ctx.fillStyle = '#ffd166';
    ctx.beginPath(); ctx.arc(b.x, b.y, b.r, 0, Math.PI*2); ctx.fill();
  }

  // draw zombies
  for(const z of state.zombies){
    // shadow
    ctx.fillStyle = 'rgba(0,0,0,0.18)';
    ctx.beginPath(); ctx.ellipse(z.x+4, z.y+8, z.r*1.1, z.r*0.6, 0, 0, Math.PI*2); ctx.fill();

    // body
    ctx.fillStyle = z.color || '#6fb98f';
    ctx.beginPath(); ctx.arc(z.x, z.y, z.r, 0, Math.PI*2); ctx.fill();
    // eyes / face detail
    ctx.fillStyle = '#071018';
    ctx.beginPath(); ctx.arc(z.x - z.r*0.28, z.y - z.r*0.22, Math.max(1.5, z.r*0.14), 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(z.x + z.r*0.28, z.y - z.r*0.22, Math.max(1.5, z.r*0.14), 0, Math.PI*2); ctx.fill();
    // hp bar for big enemies
    if(z.hp > 1){
      const w = z.r*1.8;
      ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fillRect(z.x - w/2, z.y - z.r - 10, w, 6);
      ctx.fillStyle = '#ff595e'; ctx.fillRect(z.x - w/2, z.y - z.r - 10, w * clamp(z.hp / (z.boss ? (20 + state.level*4) : (1 + Math.floor(state.level/5))), 0,1), 6);
    }
    if(z.boss){
      ctx.strokeStyle = 'rgba(255,255,255,0.08)';
      ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(z.x, z.y, z.r+6, 0, Math.PI*2); ctx.stroke();
    }
  }

  // player
  const p = state.player;
  if(p){
    // shadow
    ctx.fillStyle = 'rgba(0,0,0,0.2)';
    ctx.beginPath(); ctx.ellipse(p.x+4, p.y+8, p.r*1.1, p.r*0.6, 0, 0, Math.PI*2); ctx.fill();
    // body
    ctx.save(); ctx.translate(p.x,p.y);
    ctx.fillStyle = '#83c5be';
    ctx.beginPath(); ctx.arc(0,0,p.r,0,Math.PI*2); ctx.fill();
    // gun
    let ang = Math.atan2(state.pointer.y - p.y, state.pointer.x - p.x);
    ctx.rotate(ang);
    ctx.fillStyle = '#ffb703';
    ctx.fillRect(p.r-2, -6, p.r+18, 12);
    ctx.restore();
  }

  // HUD elements drawn via DOM
}

/* main tick */
function tick(ts){
  if(!state.lastTs) state.lastTs = ts;
  const dt = ts - state.lastTs;
  state.lastTs = ts;

  update(dt);
  render();

  requestAnimationFrame(tick);
}
requestAnimationFrame(tick);

/* ---- Game loop helpers ---- */
function spawnInitial(level){
  // immediate small spawn to start
  for(let i=0;i<Math.min(3, state.zombiesToSpawn);i++){
    spawnZombie(level); state.zombiesToSpawn--;
  }
}

/* ---- Start behavior after setting up level ---- */
function setupLevel(level){
  setupLevelImpl(level);
  // quick initial spawn so player isn't empty
  setTimeout(()=> spawnInitial(level), 300);
}
function setupLevelImpl(level){
  state.level = level;
  if(!state.player) state.player = createPlayer();
  state.zombies = [];
  state.bullets = [];
  // zombie count scales with level
  let count = Math.round(6 + level * 1.6 + (level/3));
  if(level % 10 === 0) count = Math.max(count, 8) + 1;
  state.zombiesToSpawn = count;
  state.spawnInterval = clamp(1000 - level*8, 160, 1500);
  state.lastSpawn = 0;
  state.player.x = W/2; state.player.y = H/2;
  state.player.health = Math.min(100, state.player.health + 8);
  document.getElementById('level').textContent = level;
  document.getElementById('waveNum').textContent = level;
  document.getElementById('waveType').textContent = (level % 10 === 0) ? 'Boss Level' : 'Standard';
  updateBestDisplays();
}

/* Because we referenced setupLevel earlier, define advanceLevel and start flows properly */
function advanceLevel(){
  if(state.level >= MAX_LEVEL){
    // victory
    state.running = false;
    showGameOver(true);
    return;
  }
  state.score += Math.max(0, Math.floor(30 + state.level * 4));
  setupLevelImpl(state.level + 1);
}

function startGameWithMode(mode){
  state.mode = mode;
  state.player = createPlayer();
  state.player.health = 100;
  state.score = 0;
  state.zombies = [];
  state.bullets = [];
  state.running = true;
  state.paused = false;
  setupLevelImpl(1);
  startOverlay.style.display = 'none';
  hud.style.display = 'block';
  rightHud.style.display = 'block';
  levelInfo.style.display = 'block';
  mobileControls.style.display = (mode === 'mobile') ? 'flex' : 'none';
  moveStick.style.transform = 'translate(0px,0px)';
  aimStick.style.transform = 'translate(0px,0px)';
  state.lastTs = performance.now();
}

/* Re-bind start buttons (re-declare to pick our local impl) */
document.getElementById('desktopBtn').onclick = ()=> startGameWithMode('desktop');
document.getElementById('mobileBtn').onclick = ()=> startGameWithMode('mobile');
document.getElementById('autoBtn').onclick = ()=>{
  const isMobile = /Mobi|Android|iPhone|iPad|iPod|Opera Mini/i.test(navigator.userAgent);
  startGameWithMode(isMobile ? 'mobile' : 'desktop');
};

/* onPlayerDeath implementation (stores bests) */
function onPlayerDeath(){
  state.running = false;
  if(state.score > state.bestScore) state.bestScore = Math.floor(state.score);
  if(state.level > state.bestLevel) state.bestLevel = state.level;
  localStorage.setItem('vz_best', JSON.stringify({score:state.bestScore, level:state.bestLevel}));
  showGameOver(false);
}

/* ---- Initial little spawn and helpers for saving ---- */
function updateBestDisplays(){
  document.getElementById('bestLevel').textContent = state.bestLevel;
  try { localStorage.setItem('vz_best', JSON.stringify({score:state.bestScore, level:state.bestLevel})); } catch(e){}
}

/* make sure UI buttons that reference functions are linked */
document.getElementById('restartBtn').onclick = ()=> {
  document.getElementById('gameover').style.display = 'none';
  startGameWithMode(state.mode || 'desktop');
};
document.getElementById('changeBtn').onclick = ()=> { location.reload(); };

/* Pause on visibility change */
document.addEventListener('visibilitychange', ()=> { if(document.hidden) state.paused = true; });

/* small UX: focus / keyboard hints */
window.addEventListener('keydown', (e) => {
  if((e.ctrlKey || e.metaKey) && e.key.toLowerCase()==='k'){ e.preventDefault(); }
});

/* Final polish: spawn a couple zombies at startup for flavor when overlay hidden */
setTimeout(()=> {
  // nothing started until player picks mode
}, 1200);

</script>
</body>
</html>
